import { useState, useEffect, useCallback, useRef } from 'react';
import { supabase } from '@/integrations/supabase/client';
import { WikiCategory, WikiPage } from '@/types/wiki';
import { githubWikiService } from '@/services/githubWikiService';
import { localCacheService } from '@/services/localCacheService';
import { autoWikiService } from '@/services/autoWikiService';

interface CacheStatus {
  hasData: boolean;
  lastSync: Date | null;
  totalPages: number;
  categories: number;
}

interface HybridWikiData {
  categories: WikiCategory[];
  loading: boolean;
  error: string | null;
  lastUpdated: Date | null;
  cacheStatus: CacheStatus;
  refreshData: () => Promise<void>;
  clearCache: () => Promise<void>;
  syncWithGitHub: () => Promise<void>;
  createPage: (pageData: Partial<WikiPage>) => Promise<WikiPage>;
  updatePage: (id: string, updates: Partial<WikiPage>) => Promise<WikiPage>;
  deletePage: (id: string) => Promise<void>;
  createCategory: (categoryData: Partial<WikiCategory>) => Promise<WikiCategory>;
  updateCategory: (id: string, updates: Partial<WikiCategory>) => Promise<WikiCategory>;
  deleteCategory: (id: string) => Promise<void>;
}

export const useHybridWikiData = (): HybridWikiData => {
  const [categories, setCategories] = useState<WikiCategory[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [lastUpdated, setLastUpdated] = useState<Date | null>(null);
  const [cacheStatus, setCacheStatus] = useState<CacheStatus>({
    hasData: false,
    lastSync: null,
    totalPages: 0,
    categories: 0
  });
  
  const abortControllerRef = useRef<AbortController | null>(null);
  const isInitialLoad = useRef(true);

    // Load data from local cache first, then sync with GitHub
  const loadData = useCallback(async (forceRefresh = false) => {
    if (abortControllerRef.current) {
      abortControllerRef.current.abort();
    }

    abortControllerRef.current = new AbortController();

    try {
      setLoading(true);
      setError(null);

      console.log('üîÑ Loading hybrid wiki data...');

      // Step 1: Try to load from local cache first
      let cachedData: WikiCategory[] = [];
      try {
        cachedData = await localCacheService.getWikiData();
        console.log(`üì¶ Loaded ${cachedData.length} categories from cache`);
      } catch (cacheError) {
        console.log('üì¶ No cached data available');
      }

      // Step 2: If we have cached data and not forcing refresh, use it
      if (cachedData.length > 0 && !forceRefresh) {
        setCategories(cachedData);
        setLastUpdated(new Date());
        setCacheStatus({
          hasData: true,
          lastSync: new Date(),
          totalPages: cachedData.reduce((total, cat) => total + (cat.pages?.length || 0), 0),
          categories: cachedData.length
        });
        setLoading(false);
        return;
      }

      // Step 3: Load from GitHub
      console.log('üåê Loading from GitHub...');
      const githubData = await githubWikiService.syncFromGitHub();
      
      if (abortControllerRef.current.signal.aborted) return;

      // Step 4: Merge with auto-generated content (towns/nations)
      console.log('üèóÔ∏è Merging with auto-generated content...');
      const autoGeneratedData = await autoWikiService.generateAutoPages();
      const mergedData = mergeWikiData(githubData, autoGeneratedData);

      // Step 5: Save to local cache
      await localCacheService.setWikiData(mergedData);
      
      if (abortControllerRef.current.signal.aborted) return;

      setCategories(mergedData);
      setLastUpdated(new Date());
      setCacheStatus({
        hasData: true,
        lastSync: new Date(),
        totalPages: mergedData.reduce((total, cat) => total + (cat.pages?.length || 0), 0),
        categories: mergedData.length
      });

      console.log(`‚úÖ Loaded ${mergedData.length} categories with ${mergedData.reduce((total, cat) => total + (cat.pages?.length || 0), 0)} pages`);

    } catch (err) {
      if (abortControllerRef.current.signal.aborted) return;

      console.error('‚ùå Failed to load hybrid wiki data:', err);
      setError(err instanceof Error ? err.message : 'Failed to load wiki data');
      
      // Try to use cached data as fallback
      try {
        const cachedData = await localCacheService.getWikiData();
        if (cachedData.length > 0) {
          console.log('üì¶ Using cached data as fallback');
          setCategories(cachedData);
          setCacheStatus({
            hasData: true,
            lastSync: new Date(),
            totalPages: cachedData.reduce((total, cat) => total + (cat.pages?.length || 0), 0),
            categories: cachedData.length
          });
        }
      } catch (fallbackError) {
        console.error('‚ùå No fallback data available');
      }
    } finally {
      if (!abortControllerRef.current.signal.aborted) {
        setLoading(false);
      }
    }
  }, []);

  // Merge GitHub data with auto-generated content
  const mergeWikiData = (githubData: WikiCategory[], autoData: WikiCategory[]): WikiCategory[] => {
    const merged = [...githubData];
    
    // Find or create auto-generated category
    let autoCategory = merged.find(cat => cat.slug === 'auto-generated');
    if (!autoCategory) {
      autoCategory = {
        id: 'auto-generated',
        title: 'Auto-Generated',
        slug: 'auto-generated',
        description: 'Automatically generated pages from server data',
        parent_id: null,
        order: 999,
        children: [],
        pages: []
      };
      merged.push(autoCategory);
    }

    // Merge auto-generated pages
    autoData.forEach(autoCat => {
      autoCat.pages?.forEach(page => {
        const existingPage = autoCategory!.pages?.find(p => p.slug === page.slug);
        if (!existingPage) {
          autoCategory!.pages = autoCategory!.pages || [];
          autoCategory!.pages.push({
            ...page,
            id: `auto-${page.slug}`,
            category: autoCategory!.id
          });
        }
      });
    });

    return merged;
  };

  // Refresh data from GitHub
  const refreshData = useCallback(async () => {
    console.log('üîÑ Refreshing wiki data...');
    await loadData(true);
  }, [loadData]);

  // Clear local cache
  const clearCache = useCallback(async () => {
    try {
      await localCacheService.clearWikiData();
      setCategories([]);
      setCacheStatus({
        hasData: false,
        lastSync: null,
        totalPages: 0,
        categories: 0
      });
      console.log('üì¶ Cache cleared');
    } catch (error) {
      console.error('‚ùå Failed to clear cache:', error);
    }
  }, []);

  // Sync with GitHub
  const syncWithGitHub = useCallback(async () => {
    try {
      setLoading(true);
      console.log('üîÑ Syncing with GitHub...');
      await loadData(true);
    } catch (error) {
      console.error('‚ùå Failed to sync with GitHub:', error);
      setError('Failed to sync with GitHub');
    } finally {
      setLoading(false);
    }
  }, [loadData]);

  // CRUD operations
  const createPage = useCallback(async (pageData: Partial<WikiPage>): Promise<WikiPage> => {
    try {
      const newPage = await githubWikiService.createPage(pageData);
      
      // Update local cache
      const updatedCategories = categories.map(cat => {
        if (cat.id === newPage.category) {
          return {
            ...cat,
            pages: [...(cat.pages || []), newPage]
          };
        }
        return cat;
      });
      
      setCategories(updatedCategories);
      await localCacheService.setWikiData(updatedCategories);
      
      return newPage;
    } catch (error) {
      console.error('‚ùå Failed to create page:', error);
      throw error;
    }
  }, [categories]);

  const updatePage = useCallback(async (id: string, updates: Partial<WikiPage>): Promise<WikiPage> => {
    try {
      const updatedPage = await githubWikiService.updatePage(id, updates);
      
      // Update local cache
      const updatedCategories = categories.map(cat => ({
        ...cat,
        pages: cat.pages?.map(page => 
          page.id === id ? { ...page, ...updatedPage } : page
        ) || []
      }));
      
      setCategories(updatedCategories);
      await localCacheService.setWikiData(updatedCategories);
      
      return updatedPage;
    } catch (error) {
      console.error('‚ùå Failed to update page:', error);
      throw error;
    }
  }, [categories]);

  const deletePage = useCallback(async (id: string): Promise<void> => {
    try {
      await githubWikiService.deletePage(id);
      
      // Update local cache
      const updatedCategories = categories.map(cat => ({
        ...cat,
        pages: cat.pages?.filter(page => page.id !== id) || []
      }));
      
      setCategories(updatedCategories);
      await localCacheService.setWikiData(updatedCategories);
    } catch (error) {
      console.error('‚ùå Failed to delete page:', error);
      throw error;
    }
  }, [categories]);

  const createCategory = useCallback(async (categoryData: Partial<WikiCategory>): Promise<WikiCategory> => {
    try {
      const newCategory = await githubWikiService.createCategory(categoryData);
      
      // Update local cache
      const updatedCategories = [...categories, newCategory];
      setCategories(updatedCategories);
      await localCacheService.setWikiData(updatedCategories);
      
      return newCategory;
    } catch (error) {
      console.error('‚ùå Failed to create category:', error);
      throw error;
    }
  }, [categories]);

  const updateCategory = useCallback(async (id: string, updates: Partial<WikiCategory>): Promise<WikiCategory> => {
    try {
      const updatedCategory = await githubWikiService.updateCategory(id, updates);
      
      // Update local cache
      const updatedCategories = categories.map(cat => 
        cat.id === id ? { ...cat, ...updatedCategory } : cat
      );
      
      setCategories(updatedCategories);
      await localCacheService.setWikiData(updatedCategories);
      
      return updatedCategory;
    } catch (error) {
      console.error('‚ùå Failed to update category:', error);
      throw error;
    }
  }, [categories]);

  const deleteCategory = useCallback(async (id: string): Promise<void> => {
    try {
      await githubWikiService.deleteCategory(id);
      
      // Update local cache
      const updatedCategories = categories.filter(cat => cat.id !== id);
      setCategories(updatedCategories);
      await localCacheService.setWikiData(updatedCategories);
    } catch (error) {
      console.error('‚ùå Failed to delete category:', error);
      throw error;
    }
  }, [categories]);

  // Initial load
  useEffect(() => {
    if (isInitialLoad.current) {
      loadData(true); // Always force refresh from GitHub on mount
      isInitialLoad.current = false;
    }
  }, [loadData]);

  // Cleanup
  useEffect(() => {
    return () => {
      if (abortControllerRef.current) {
        abortControllerRef.current.abort();
      }
    };
  }, []);

  return {
    categories,
    loading,
    error,
    lastUpdated,
    cacheStatus,
    refreshData,
    clearCache,
    syncWithGitHub,
    createPage,
    updatePage,
    deletePage,
    createCategory,
    updateCategory,
    deleteCategory
  };
}; 