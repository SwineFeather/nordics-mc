const __vite__mapDeps=(i,m=__vite__mapDeps,d=(m.f||(m.f=["assets/index-BDwxLbfg.js","assets/index-BTrpatIL.css"])))=>i.map(i=>d[i]);
var $=Object.defineProperty;var E=(h,e,o)=>e in h?$(h,e,{enumerable:!0,configurable:!0,writable:!0,value:o}):h[e]=o;var m=(h,e,o)=>E(h,typeof e!="symbol"?e+"":e,o);import{bi as p,s as g}from"./index-BDwxLbfg.js";class w{static async getFileStructureOnly(){try{console.log("📖 Loading wiki structure only (fast)...");const e=await this.getFileStructureViaPathDiscovery();if(e.length===0){console.log("⚠️ No files found with optimized discovery, trying original service...");const{SupabaseWikiService:o}=await p(async()=>{const{SupabaseWikiService:l}=await import("./index-BDwxLbfg.js").then(a=>a.cf);return{SupabaseWikiService:l}},__vite__mapDeps([0,1])),s=await o.getFileStructure();return console.log("✅ Original service found files:",s.length),s}return console.log("✅ Structure loaded:",e),e}catch(e){console.error("❌ Failed to load wiki structure:",e);try{console.log("🔄 Trying original service as fallback...");const{SupabaseWikiService:o}=await p(async()=>{const{SupabaseWikiService:l}=await import("./index-BDwxLbfg.js").then(a=>a.cf);return{SupabaseWikiService:l}},__vite__mapDeps([0,1])),s=await o.getFileStructure();return console.log("✅ Original service fallback successful:",s.length),s}catch(o){throw console.error("❌ Original service fallback also failed:",o),e}}}static async getFileStructureViaPathDiscovery(){console.log("🔍 Using comprehensive file discovery...");const e=[],o=new Set;try{const{data:t,error:n}=await g.storage.from(this.BUCKET_NAME).list("",{limit:1e3});if(!n&&t&&t.length>0){console.log(`📁 Found ${t.length} items in root directory`);for(const i of t)console.log(`📄 Root item: ${i.name} (metadata: ${!!i.metadata})`),i.metadata&&i.name.endsWith(".md")?(e.push({type:"file",name:i.name,path:i.name,isPage:!0}),console.log(`✅ Found root file: ${i.name}`)):i.metadata||(o.add(i.name),console.log(`📂 Found root folder: ${i.name}`),await this.exploreFolderRecursively(i.name,e,o))}}catch(t){console.error("Error listing root directory:",t)}const s=["Nordics","Nordics/nations","Nordics/towns","Nordics/server-events"];for(const t of s)try{const{data:n,error:i}=await g.storage.from(this.BUCKET_NAME).list(t,{limit:100});if(!i&&n&&n.length>0){console.log(`📁 Found ${n.length} items in ${t}`),o.add(t);for(const c of n){const d=`${t}/${c.name}`;c.metadata&&c.name.endsWith(".md")?(e.push({type:"file",name:c.name,path:d,isPage:!0}),console.log(`✅ Found file: ${d}`)):c.metadata||(o.add(d),console.log(`📂 Found subfolder: ${d}`),await this.exploreFolderRecursively(d,e,o))}}}catch(n){console.log(`⚠️ Could not list directory ${t}:`,n)}const l=["Nordics/README.md","Nordics/nations/README.md","Nordics/towns/README.md","Nordics/nations/constellation.md","Nordics/towns/garvia/README.md","Nordics/towns/sogndalsfjorden.md","Nordics/towns/kingdom_of_albion/england/lundenwic.md","Nordics/towns/northstar/README.md","Nordics/server-events/terrain-incidents/northstar-forest-fire.md","Nordics/server-events/terrain-incidents/the-sapmi-forest-fire.md"];for(const t of l)try{const{data:n,error:i}=await g.storage.from(this.BUCKET_NAME).download(t);if(!i&&n){if(console.log(`✅ Confirmed file exists: ${t}`),!e.find(u=>u.path===t)){const u=t.split("/").pop()||"";e.push({type:"file",name:u,path:t,isPage:!0})}const d=t.split("/");for(let u=0;u<d.length-1;u++){const f=d.slice(0,u+1).join("/");o.add(f)}}else console.log(`❌ File not found: ${t} (${(i==null?void 0:i.message)||"No data"})`)}catch(n){console.log(`❌ Error checking file ${t}:`,n)}const a=[];for(const t of o){const n=t.split("/"),c={type:"folder",name:n[n.length-1],path:t,children:[],isGroup:!0,isPage:!1};a.push(c)}const r=this.buildHierarchicalStructure(e,a);if(e.length===0){console.log("🔄 No files found, trying alternative paths...");const t=["README.md","the-world/README.md","the-world/nations/README.md","the-world/towns/README.md","the-world/nations/constellation.md","the-world/towns/garvia/README.md"];for(const n of t)try{const{data:i,error:c}=await g.storage.from(this.BUCKET_NAME).download(n);if(!c&&i){console.log(`✅ Found file with alternative path: ${n}`);const d=n.split("/").pop()||"";e.push({type:"file",name:d,path:n,isPage:!0});const u=n.split("/");for(let f=0;f<u.length-1;f++){const y=u.slice(0,f+1).join("/");o.add(y)}}}catch{console.log(`❌ Alternative path also failed: ${n}`)}}return console.log(`✅ Discovered ${e.length} files and ${a.length} folders`),console.log("📁 Files:",e.map(t=>t.path)),console.log("📂 Folders:",Array.from(o)),r}static async exploreFolderRecursively(e,o,s){try{console.log(`🔍 Exploring folder: ${e}`);const{data:l,error:a}=await g.storage.from(this.BUCKET_NAME).list(e,{limit:1e3});if(a){console.error(`Error listing folder ${e}:`,a);return}if(!l||l.length===0){console.log(`📭 No items found in folder: ${e}`);return}console.log(`📁 Found ${l.length} items in folder: ${e}`);for(const r of l){const t=`${e}/${r.name}`;r.metadata&&r.name.endsWith(".md")?(o.push({type:"file",name:r.name,path:t,isPage:!0}),console.log(`✅ Found file: ${t}`)):r.metadata||(s.add(t),console.log(`📂 Found subfolder: ${t}`),await this.exploreFolderRecursively(t,o,s))}}catch(l){console.error(`❌ Error exploring folder ${e}:`,l)}}static buildHierarchicalStructure(e,o){console.log("🔨 Building hierarchical structure..."),console.log("📁 Input files:",e.length),console.log("📂 Input folders:",o.length);const s=[],l=new Map;o.sort((r,t)=>r.path.split("/").length-t.path.split("/").length);for(const r of o)l.set(r.path,r),console.log(`📁 Created folder: ${r.name} at ${r.path}`);for(const r of e){const t=r.path.split("/");if(t.length>1){const n=t.slice(0,-1).join("/"),i=l.get(n);i?(i.children=i.children||[],i.children.push(r),console.log(`📄 Added file ${r.name} to folder ${n}`)):(console.log(`⚠️ Parent folder not found for file ${r.path}: ${n}`),s.push(r))}else s.push(r),console.log(`📄 Added root file: ${r.name}`)}for(const r of o){const t=r.path.split("/");if(t.length===1)s.push(r),console.log(`📁 Added root folder: ${r.name}`);else{const n=t.slice(0,-1).join("/"),i=l.get(n);i?(i.children=i.children||[],i.children.push(r),console.log(`📁 Added nested folder ${r.name} to ${n}`)):(console.log(`⚠️ Parent folder not found for nested folder ${r.path}: ${n}`),s.push(r))}}const a=s.sort((r,t)=>r.name.localeCompare(t.name));return console.log("✅ Final structure:",a.map(r=>{var t;return`${r.type}: ${r.name} (${((t=r.children)==null?void 0:t.length)||0} children)`})),a}static async convertToWikiDataMinimal(e){var l;console.log("🔄 Converting structure to wiki data (minimal)...");const o=[],s=async a=>{const r=[];if(a.children){for(const t of a.children)if(t.type==="file"&&t.name.endsWith(".md")){const n=await this.convertFileToPageMinimal(t,a.path);n&&r.push(n)}else if(t.type==="folder"){const n=await s(t);n&&r.push(...n.pages||[])}}return r.length===0?null:{id:a.path,title:this.formatTitle(a.name),slug:a.name.toLowerCase().replace(/\s+/g,"-"),description:`Pages in ${a.name}`,order:0,pages:r.sort((t,n)=>t.order-n.order)}};for(const a of e)if(a.type==="folder"){const r=await s(a);r&&(o.push(r),console.log(`📁 Created category: ${r.title} with ${((l=r.pages)==null?void 0:l.length)||0} pages`))}return console.log(`✅ Converted to ${o.length} categories`),o}static async convertFileToPageMinimal(e,o){if(!e.name.endsWith(".md"))return null;const s=this.formatTitle(e.name.replace(".md","")),a=e.path.split("/").join("-").replace(".md","");return{id:e.path,title:s,slug:a,content:"",status:"published",authorId:"system",authorName:"System",createdAt:new Date().toISOString(),updatedAt:new Date().toISOString(),category:o,order:0,githubPath:e.path}}static async getPageContent(e){try{console.log(`📄 Loading content for: ${e}`);const{data:o,error:s}=await g.storage.from(this.BUCKET_NAME).download(e);if(s)return console.error(`Error downloading file ${e}:`,s),null;if(!o)return console.error(`File ${e} not found`),null;const l=await o.text();return console.log(`✅ Content loaded: ${e} (${l.length} characters)`),l}catch(o){return console.error(`❌ Failed to load content for ${e}:`,o),null}}static async getPageByPath(e){try{const o=await this.getPageContent(e);if(!o)return null;const{frontmatter:s,markdown:l}=this.parseFrontmatter(o),a=e.split("/").pop()||"";return{id:e,title:(s==null?void 0:s.title)||this.formatTitle(a.replace(".md","")),slug:a.replace(".md",""),content:l,status:"published",authorId:"system",authorName:"System",createdAt:new Date().toISOString(),updatedAt:new Date().toISOString(),category:e.split("/").slice(0,-1).join("/"),order:0,githubPath:e}}catch(o){return console.error("Failed to get page by path:",o),null}}static async searchPages(e){try{const o=await this.getFileStructureOnly(),s=[],l=async r=>{for(const t of r)if(t.type==="file"&&t.name.endsWith(".md")){const n={id:t.path,title:this.formatTitle(t.name.replace(".md","")),slug:t.name.replace(".md",""),content:"",status:"published",authorId:"system",authorName:"System",createdAt:new Date().toISOString(),updatedAt:new Date().toISOString(),category:t.path.split("/").slice(0,-1).join("/"),order:0};s.push(n)}else t.type==="folder"&&t.children&&await l(t.children)};await l(o);const a=e.toLowerCase();return s.filter(r=>r.title.toLowerCase().includes(a)||r.slug.toLowerCase().includes(a))}catch(o){return console.error("Failed to search pages:",o),[]}}static async getFileContent(e){const o=await this.getPageContent(e);if(!o)throw new Error(`File ${e} not found`);return o}static parseFrontmatter(e){const o=/^---\s*\n([\s\S]*?)\n---\s*\n([\s\S]*)$/,s=e.match(o);if(s)try{const l=s[1],a=s[2],r={};return l.split(`
`).forEach(t=>{const n=t.indexOf(":");if(n>0){const i=t.substring(0,n).trim(),c=t.substring(n+1).trim();r[i]=c}}),{frontmatter:r,markdown:a}}catch(l){console.error("Failed to parse frontmatter:",l)}return{markdown:e}}static formatTitle(e){return e.replace(/[-_]/g," ").replace(/\b\w/g,o=>o.toUpperCase()).trim()}}m(w,"BUCKET_NAME","wiki"),m(w,"BASE_PATH","Nordics");export{w as O};
