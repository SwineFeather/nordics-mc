# AI Knowledgebase: Nordics Supabase Access Instructions

## Overview
- Thor the Bot (the Nordics AI) has full read access to the Supabase storage **wiki bucket** only.
- Thor the Bot can read the following Supabase tables and views, but must not access any other tables or sensitive columns.
- For each table, a description is provided to help Thor quickly find the right information for user questions.
- Use this document as a reference for answering questions about the Nordics Minecraft server, its achievements, towns, nations, companies, forums, and player stats.

---

## Supabase Storage
- **wiki bucket**: Contains wiki pages and documents for the Nordics community. Use this for in-depth guides, rules, and player-written content.

---

## Supabase Tables & Views (Allowed)

### award_leaderboard (view)
- **Purpose:** Shows the top players for each award, including their points, medals, and rank. Use this to answer questions about who leads in specific awards or achievements.

### achievement_tiers
- **Purpose:** Lists the different tiers for each achievement, including thresholds, names, descriptions, and points. Use this to explain what is required for each achievement tier.

### achievement_definitions
- **Purpose:** Defines all achievements, their names, descriptions, and the stat they track. Use this to explain what achievements exist and what they mean.

### companies
- **Purpose:** Contains information about player-created companies, including name, description, members, revenue, and more. Use this to answer questions about companies, their stats, and their members. Do not access sensitive columns like emails.

### forum_categories
- **Purpose:** Lists all forum categories, their names, descriptions, and organization. Use this to help users find the right forum section.

### forum_posts
- **Purpose:** Contains forum posts, including title, content, author, and category. Use this to answer questions about forum discussions, but do not access sensitive author information.

### level_definitions
- **Purpose:** Defines player and town levels, including XP required and level titles. Use this to explain leveling systems.

### nations
- **Purpose:** Contains all nations on the server, including their name, leader, capital, and balance. Use this to answer questions about nations, their leaders, and their balances. Users may ask about nation balances.

### towns
- **Purpose:** Contains all towns on the server, including name, mayor, balance, location, and residents. Use this to answer questions about towns, their balances, and their mayors. Users may ask about town balances.

### trail_paths
- **Purpose:** Lists paths and trails around the world, with descriptions of where they go. Use this to help users find or learn about trails.

### player_stats
- **Purpose:** Contains player statistics in JSON format. Use this to answer questions about individual player stats.

### players
- **Purpose:** Contains basic player info, including name, level, and XP. Use this to answer questions about players, but do not access sensitive data.

### residents
- **Purpose:** Contains information about residents, their town/nation, roles, and balances. Use this to answer questions about residents, their roles, and their balances.

### shops
- **Purpose:** Contains information about player shops, including items for sale, prices, and owners. Use this to answer questions about shops and the marketplace.

### town_unlocked_achievements
- **Purpose:** Tracks which achievements have been unlocked by towns. Use this to answer questions about town achievements.

### town_level_definitions
- **Purpose:** Defines town levels and XP requirements. Use this to explain how towns level up.

### unlocked_achievements
- **Purpose:** Tracks which achievements have been unlocked by players. Use this to answer questions about player achievements.

### player_leaderboard (view)
- **Purpose:** Shows the top players by points and medals. Use this to answer questions about the best players on the server.

---

## Usage Notes
- Only use the tables and storage listed above. Do not access any other tables or columns not described here.
- Be quick and efficient in finding information. Use the table descriptions to match user questions to the right data source.
- If a user asks about something not covered by these tables or the wiki bucket, politely explain that the information is not available.

---

# (The rest of this document contains the schema and SQL for each table/view for reference)

'award_leaderboard'
  create view public.award_leaderboard as
  select
    pa.award_id,
    pa.award_name,
    pa.player_uuid,
    p.name as player_name,
    pa.points,
    pa.medal,
    pa.tier,
    pa.achieved_at,
    row_number() over (
      partition by
        pa.award_id
      order by
        pa.points desc
    ) as rank
  from
    player_awards pa
    join players p on pa.player_uuid = p.uuid
  order by
    pa.award_id,
    pa.points desc;

'achievement_tiers'
  create table public.achievement_tiers (
    id uuid not null default gen_random_uuid (),
    achievement_id text not null,
    tier integer not null,
    name text not null,
    description text not null,
    threshold numeric not null,
    icon text not null,
    points integer not null,
    created_at timestamp with time zone not null default now(),
    constraint achievement_tiers_pkey primary key (id),
    constraint achievement_tiers_achievement_id_tier_key unique (achievement_id, tier),
    constraint achievement_tiers_achievement_id_fkey foreign KEY (achievement_id) references achievement_definitions (id) on delete CASCADE
  ) TABLESPACE pg_default;

  create index IF not exists idx_achievement_tiers_achievement_id on public.achievement_tiers using btree (achievement_id) TABLESPACE pg_default;

'achievement_definitions'
  create table public.achievement_definitions (
    id text not null,
    name text not null,
    description text not null,
    stat text not null,
    created_at timestamp with time zone not null default now(),
    constraint achievement_definitions_pkey primary key (id)
  ) TABLESPACE pg_default;

'companies'
  create table public.companies (
    id uuid not null default gen_random_uuid (),
    name character varying(255) not null,
    slug character varying(255) not null,
    tagline character varying(500) null,
    description text null,
    website_url character varying(500) null,
    email character varying(255) null,
    discord_invite character varying(255) null,
    discord_server_id character varying(255) null,
    logo_url character varying(500) null,
    banner_url character varying(500) null,
    primary_color character varying(7) null,
    secondary_color character varying(7) null,
    business_type character varying(100) null,
    industry character varying(100) null,
    founded_date date null,
    headquarters_world character varying(100) null,
    headquarters_coords character varying(100) null,
    social_links jsonb null,
    member_count integer null default 0,
    max_members integer null,
    is_public boolean null default true,
    is_featured boolean null default false,
    gallery_images jsonb null,
    featured_products jsonb null,
    achievements jsonb null,
    total_revenue numeric(15, 2) null default 0,
    total_transactions integer null default 0,
    average_rating numeric(3, 2) null default 0,
    review_count integer null default 0,
    owner_uuid uuid not null,
    ceo_uuid uuid null,
    executives jsonb null,
    members jsonb null,
    status character varying(50) null default 'active'::character varying,
    verification_status character varying(50) null default 'unverified'::character varying,
    verification_date timestamp with time zone null,
    verified_by uuid null,
    keywords text[] null,
    tags text[] null,
    created_at timestamp with time zone null default now(),
    updated_at timestamp with time zone null default now(),
    last_activity timestamp with time zone null default now(),
    parent_company_id uuid null,
    town_id integer null,
    company_type character varying(50) null default 'independent'::character varying,
    constraint companies_pkey primary key (id),
    constraint companies_slug_key unique (slug),
    constraint companies_town_id_fkey foreign KEY (town_id) references towns (id) on delete set null,
    constraint companies_parent_company_id_fkey foreign KEY (parent_company_id) references companies (id) on delete set null,
    constraint valid_member_count check ((member_count >= 0)),
    constraint valid_rating check (
      (
        (average_rating >= (0)::numeric)
        and (average_rating <= (5)::numeric)
      )
    ),
    constraint valid_revenue check ((total_revenue >= (0)::numeric)),
    constraint companies_company_type_check check (
      (
        (company_type)::text = any (
          (
            array[
              'parent'::character varying,
              'subsidiary'::character varying,
              'independent'::character varying
            ]
          )::text[]
        )
      )
    ),
    constraint valid_transactions check ((total_transactions >= 0)),
    constraint valid_hex_color check (
      (
        ((primary_color)::text ~ '^#[0-9A-Fa-f]{6}$'::text)
        or (primary_color is null)
      )
    ),
    constraint valid_hex_color_secondary check (
      (
        (
          (secondary_color)::text ~ '^#[0-9A-Fa-f]{6}$'::text
        )
        or (secondary_color is null)
      )
    ),
    constraint valid_max_members check (
      (
        (max_members is null)
        or (max_members > 0)
      )
    )
  ) TABLESPACE pg_default;

  create index IF not exists idx_companies_name on public.companies using btree (name) TABLESPACE pg_default;

  create index IF not exists idx_companies_slug on public.companies using btree (slug) TABLESPACE pg_default;

  create index IF not exists idx_companies_owner on public.companies using btree (owner_uuid) TABLESPACE pg_default;

  create index IF not exists idx_companies_status on public.companies using btree (status) TABLESPACE pg_default;

  create index IF not exists idx_companies_featured on public.companies using btree (is_featured) TABLESPACE pg_default;

  create index IF not exists idx_companies_industry on public.companies using btree (industry) TABLESPACE pg_default;

  create index IF not exists idx_companies_created_at on public.companies using btree (created_at) TABLESPACE pg_default;

  create index IF not exists idx_companies_rating on public.companies using btree (average_rating desc) TABLESPACE pg_default;

  create index IF not exists idx_companies_parent_id on public.companies using btree (parent_company_id) TABLESPACE pg_default;

  create index IF not exists idx_companies_town_id on public.companies using btree (town_id) TABLESPACE pg_default;

  create index IF not exists idx_companies_company_type on public.companies using btree (company_type) TABLESPACE pg_default;

  create trigger trigger_companies_updated_at BEFORE
  update on companies for EACH row
  execute FUNCTION update_companies_updated_at ();


'forum_categories'
  create table public.forum_categories (
    id uuid not null default gen_random_uuid (),
    name text not null,
    description text null,
    slug text not null,
    icon text null default 'message-square'::text,
    color text null default '#3b82f6'::text,
    order_index integer null default 0,
    is_moderator_only boolean null default false,
    created_at timestamp with time zone null default now(),
    updated_at timestamp with time zone null default now(),
    nation_name text null,
    town_name text null,
    is_archived boolean null default false,
    constraint forum_categories_pkey primary key (id),
    constraint forum_categories_slug_key unique (slug)
  ) TABLESPACE pg_default;

  create index IF not exists idx_forum_categories_nation_name on public.forum_categories using btree (nation_name) TABLESPACE pg_default;

  create index IF not exists idx_forum_categories_town_name on public.forum_categories using btree (town_name) TABLESPACE pg_default;

  create index IF not exists idx_forum_categories_nation_town on public.forum_categories using btree (nation_name, town_name) TABLESPACE pg_default;

  create index IF not exists idx_forum_categories_is_archived on public.forum_categories using btree (is_archived) TABLESPACE pg_default;

  create index IF not exists idx_forum_categories_updated_at on public.forum_categories using btree (updated_at) TABLESPACE pg_default;

  create trigger trigger_update_forum_categories_updated_at BEFORE
  update on forum_categories for EACH row
  execute FUNCTION update_forum_categories_updated_at ();

  create trigger update_forum_categories_updated_at BEFORE
  update on forum_categories for EACH row
  execute FUNCTION trigger_set_timestamp ();

'forum_posts'
  create table public.forum_posts (
    id uuid not null default gen_random_uuid (),
    title text not null,
    content text not null,
    category_id uuid null,
    author_id uuid null,
    is_pinned boolean null default false,
    is_locked boolean null default false,
    is_featured boolean null default false,
    view_count integer null default 0,
    created_at timestamp with time zone null default now(),
    updated_at timestamp with time zone null default now(),
    reply_count integer null default 0,
    post_type public.post_type null default 'discussion'::post_type,
    tags jsonb null default '[]'::jsonb,
    search_vector tsvector null,
    constraint forum_posts_pkey primary key (id),
    constraint forum_posts_author_id_fkey foreign KEY (author_id) references profiles (id) on delete CASCADE,
    constraint forum_posts_category_id_fkey foreign KEY (category_id) references forum_categories (id) on delete CASCADE
  ) TABLESPACE pg_default;

  create index IF not exists forum_posts_post_type_idx on public.forum_posts using btree (post_type) TABLESPACE pg_default;

  create index IF not exists forum_posts_search_vector_idx on public.forum_posts using gin (search_vector) TABLESPACE pg_default;

  create trigger trigger_update_forum_post_search_vector BEFORE INSERT
  or
  update on forum_posts for EACH row
  execute FUNCTION update_forum_post_search_vector ();

  create trigger update_forum_posts_updated_at BEFORE
  update on forum_posts for EACH row
  execute FUNCTION trigger_set_timestamp ();


'level_definitions'
  create table public.level_definitions (
    level integer not null,
    xp_required bigint not null,
    title text not null default ''::text,
    description text null default ''::text,
    color text null default '#3b82f6'::text,
    created_at timestamp with time zone null default now(),
    updated_at timestamp with time zone null default now(),
    constraint level_definitions_pkey primary key (level)
  ) TABLESPACE pg_default;

'nations' #It should be suggested that the users can ask about nation balances.
  create table public.nations (
    id serial not null,
    name character varying(255) not null,
    leader_uuid character varying(36) not null,
    king_uuid character varying(36) not null,
    king_name character varying(255) null,
    leader_name character varying(255) null,
    capital_town_id integer null,
    capital_town_name character varying(255) null,
    capital_name character varying(255) null,
    capital_uuid character varying(36) null,
    balance numeric(10, 2) null default 0.0,
    board text null,
    tag character varying(10) null,
    taxes numeric(10, 2) null,
    town_tax numeric(10, 2) null,
    max_towns integer null,
    is_open boolean null default false,
    is_public boolean null default false,
    towns_count integer null default 0,
    residents_count integer null default 0,
    ally_count integer null default 0,
    enemy_count integer null default 0,
    last_activity timestamp without time zone null,
    activity_score integer null default 0,
    growth_rate numeric(5, 4) null default 0.0,
    created_at timestamp without time zone null default now(),
    last_updated timestamp without time zone null default now(),
    image_url text null,
    constraint nations_pkey primary key (id),
    constraint nations_name_key unique (name)
  ) TABLESPACE pg_default;

  create index IF not exists idx_nations_image_url on public.nations using btree (image_url) TABLESPACE pg_default;

  create index IF not exists idx_nations_activity on public.nations using btree (activity_score desc) TABLESPACE pg_default;

  create index IF not exists idx_nations_balance on public.nations using btree (balance desc) TABLESPACE pg_default;

  create index IF not exists idx_nations_towns on public.nations using btree (towns_count desc) TABLESPACE pg_default;

  create index IF not exists idx_nations_name on public.nations using btree (name) TABLESPACE pg_default;

  create index IF not exists idx_nations_leader_uuid on public.nations using btree (leader_uuid) TABLESPACE pg_default;

'towns' #Use this to find all the towns on the server, you can also find the balance of the towns.
  create table public.towns (
    id serial not null,
    name character varying(255) not null,
    mayor_uuid character varying(36) not null,
    mayor_name character varying(255) null,
    balance numeric(10, 2) null default 0.0,
    world_name character varying(50) null,
    location_x integer null,
    location_z integer null,
    spawn_x double precision null,
    spawn_y double precision null,
    spawn_z double precision null,
    spawn_yaw double precision null,
    spawn_pitch double precision null,
    board text null,
    tag character varying(10) null,
    is_public boolean null default false,
    is_open boolean null default false,
    max_residents integer null,
    min_residents integer null,
    max_plots integer null,
    min_plots integer null,
    taxes numeric(10, 2) null,
    plot_tax numeric(10, 2) null,
    shop_tax numeric(10, 2) null,
    embassy_tax numeric(10, 2) null,
    plot_price numeric(10, 2) null,
    nation_id integer null,
    nation_name character varying(255) null,
    nation_uuid character varying(36) null,
    is_capital boolean null default false,
    residents_count integer null default 0,
    plots_count integer null default 0,
    home_block_count integer null default 0,
    shop_plot_count integer null default 0,
    embassy_plot_count integer null default 0,
    wild_plot_count integer null default 0,
    residents jsonb null,
    last_activity timestamp without time zone null,
    activity_score integer null default 0,
    growth_rate numeric(5, 4) null default 0.0,
    market_value numeric(10, 2) null default 0.0,
    created_at timestamp without time zone null default now(),
    last_updated timestamp without time zone null default now(),
    level integer not null default 1,
    total_xp bigint not null default 0,
    image_url text null,
    constraint towns_pkey primary key (id),
    constraint towns_name_key unique (name)
  ) TABLESPACE pg_default;

  create index IF not exists idx_towns_level on public.towns using btree (level) TABLESPACE pg_default;

  create index IF not exists idx_towns_total_xp on public.towns using btree (total_xp) TABLESPACE pg_default;

  create index IF not exists idx_towns_activity on public.towns using btree (activity_score desc) TABLESPACE pg_default;

  create index IF not exists idx_towns_balance on public.towns using btree (balance desc) TABLESPACE pg_default;

  create index IF not exists idx_towns_residents on public.towns using btree (residents_count desc) TABLESPACE pg_default;

  create index IF not exists idx_towns_name on public.towns using btree (name) TABLESPACE pg_default;

  create index IF not exists idx_towns_mayor_uuid on public.towns using btree (mayor_uuid) TABLESPACE pg_default;

'trail_paths' #Used to find paths around the world, description will define where they go.
  create table public.trail_paths (
    id serial not null,
    name character varying(255) not null,
    version integer null default 1,
    description text null,
    radius integer null default 3,
    creation_date timestamp with time zone null default now(),
    created_by character varying(255) null,
    max_points integer null default 0,
    display_particle character varying(100) null,
    tracked_path jsonb null,
    width integer null default 1,
    blocks text null default ''::text,
    geojson text null,
    constraint trail_paths_pkey primary key (id),
    constraint trail_paths_name_key unique (name)
  ) TABLESPACE pg_default;

'player_stats'
  create table public.player_stats (
    player_uuid uuid not null,
    stats jsonb not null default '{}'::jsonb,
    last_updated bigint not null,
    created_at timestamp with time zone null default now(),
    updated_at timestamp with time zone null default now(),
    constraint player_stats_pkey primary key (player_uuid),
    constraint player_stats_player_uuid_fkey foreign KEY (player_uuid) references players (uuid) on delete CASCADE
  ) TABLESPACE pg_default;

  create index IF not exists idx_player_stats_uuid on public.player_stats using btree (player_uuid) TABLESPACE pg_default;

  create index IF not exists idx_player_stats_last_updated on public.player_stats using btree (last_updated) TABLESPACE pg_default;

  create index IF not exists idx_player_stats_gin on public.player_stats using gin (stats) TABLESPACE pg_default;

'players'
  create table public.players (
    uuid uuid not null,
    name character varying(255) not null,
    last_seen bigint not null,
    created_at timestamp with time zone null default now(),
    updated_at timestamp with time zone null default now(),
    level integer null default 1,
    total_xp bigint null default 0,
    constraint players_pkey primary key (uuid)
  ) TABLESPACE pg_default;

  create index IF not exists idx_players_name on public.players using btree (name) TABLESPACE pg_default;

  create index IF not exists idx_players_last_seen on public.players using btree (last_seen) TABLESPACE pg_default;

'residents'
  create table public.residents (
    uuid character varying(36) not null,
    name character varying(255) null,
    town_id integer null,
    town_name character varying(255) null,
    nation_id integer null,
    nation_name character varying(255) null,
    is_mayor boolean null default false,
    is_king boolean null default false,
    is_assistant boolean null default false,
    is_treasurer boolean null default false,
    last_login timestamp without time zone null,
    last_activity timestamp without time zone null,
    total_playtime bigint null default 0,
    activity_score integer null default 0,
    login_count integer null default 0,
    balance numeric(10, 2) null default 0.0,
    total_deposits numeric(10, 2) null default 0.0,
    total_withdrawals numeric(10, 2) null default 0.0,
    total_taxes_paid numeric(10, 2) null default 0.0,
    owned_plots integer null default 0,
    owned_towns integer null default 0,
    owned_nations integer null default 0,
    permissions jsonb null,
    registered timestamp without time zone null default now(),
    last_town_change timestamp without time zone null,
    last_nation_change timestamp without time zone null,
    constraint residents_pkey primary key (uuid)
  ) TABLESPACE pg_default;

  create index IF not exists idx_residents_activity on public.residents using btree (activity_score desc) TABLESPACE pg_default;

  create index IF not exists idx_residents_playtime on public.residents using btree (total_playtime desc) TABLESPACE pg_default;

  create index IF not exists idx_residents_wealth on public.residents using btree (total_deposits desc) TABLESPACE pg_default;

  create index IF not exists idx_residents_uuid on public.residents using btree (uuid) TABLESPACE pg_default;

  create index IF not exists idx_residents_town_id on public.residents using btree (town_id) TABLESPACE pg_default;

  create index IF not exists idx_residents_nation_id on public.residents using btree (nation_id) TABLESPACE pg_default;

'shops'
  create table public.shops (
    id text not null,
    owner_uuid text not null,
    world text not null,
    x integer not null,
    y integer not null,
    z integer not null,
    item_type text not null,
    item_amount integer not null,
    item_durability integer not null default 0,
    item_display_name text null,
    item_lore text[] null,
    item_enchants jsonb null,
    item_custom_model_data integer null,
    item_unbreakable boolean null default false,
    price numeric(10, 2) not null,
    type text not null,
    stock integer not null,
    unlimited boolean not null default false,
    last_updated bigint not null,
    description text null,
    company_id uuid null,
    is_featured boolean null default false,
    constraint shops_pkey primary key (id),
    constraint shops_company_id_fkey foreign KEY (company_id) references companies (id) on delete set null,
    constraint shops_type_check check ((type = any (array['buy'::text, 'sell'::text])))
  ) TABLESPACE pg_default;

  create index IF not exists idx_shops_owner on public.shops using btree (owner_uuid) TABLESPACE pg_default;

  create index IF not exists idx_shops_world on public.shops using btree (world) TABLESPACE pg_default;

  create index IF not exists idx_shops_type on public.shops using btree (type) TABLESPACE pg_default;

  create index IF not exists idx_shops_item_type on public.shops using btree (item_type) TABLESPACE pg_default;

  create index IF not exists idx_shops_last_updated on public.shops using btree (last_updated) TABLESPACE pg_default;

  create index IF not exists idx_shops_company_id on public.shops using btree (company_id) TABLESPACE pg_default;

  create index IF not exists idx_shops_featured on public.shops using btree (is_featured) TABLESPACE pg_default;

'town_unlocked_achievements '
  create table public.town_unlocked_achievements (
    id uuid not null default gen_random_uuid (),
    town_id text not null,
    tier_id uuid not null,
    unlocked_at timestamp with time zone null default now(),
    claimed_at timestamp with time zone null,
    is_claimed boolean null default false,
    constraint town_unlocked_achievements_pkey primary key (id),
    constraint town_unlocked_achievements_town_id_tier_id_key unique (town_id, tier_id),
    constraint fk_town_unlocked_achievements_tier_id foreign KEY (tier_id) references town_achievement_tiers (id) on delete CASCADE
  ) TABLESPACE pg_default;

  create index IF not exists idx_town_unlocked_achievements_town_id on public.town_unlocked_achievements using btree (town_id) TABLESPACE pg_default;

  create index IF not exists idx_town_unlocked_achievements_tier_id on public.town_unlocked_achievements using btree (tier_id) TABLESPACE pg_default;

'town_level_definitions'
  create table public.town_level_definitions (
    level integer not null,
    xp_required bigint not null,
    title text not null default ''::text,
    description text null default ''::text,
    color text null default '#3b82f6'::text,
    created_at timestamp with time zone null default now(),
    updated_at timestamp with time zone null default now(),
    constraint town_level_definitions_pkey primary key (level)
  ) TABLESPACE pg_default;

  create index IF not exists idx_town_level_definitions_level on public.town_level_definitions using btree (level) TABLESPACE pg_default;

'unlocked_achievements'
  create table public.unlocked_achievements (
    id uuid not null default gen_random_uuid (),
    player_uuid text not null,
    tier_id uuid not null,
    unlocked_at timestamp with time zone not null default now(),
    claimed_at timestamp with time zone null,
    is_claimed boolean null default false,
    constraint unlocked_achievements_pkey primary key (id),
    constraint unique_player_tier unique (player_uuid, tier_id),
    constraint unlocked_achievements_player_uuid_tier_id_key unique (player_uuid, tier_id),
    constraint unlocked_achievements_tier_id_fkey foreign KEY (tier_id) references achievement_tiers (id) on delete CASCADE
  ) TABLESPACE pg_default;

  create index IF not exists idx_unlocked_achievements_player_uuid on public.unlocked_achievements using btree (player_uuid) TABLESPACE pg_default;

  create index IF not exists idx_unlocked_achievements_tier_id on public.unlocked_achievements using btree (tier_id) TABLESPACE pg_default;

  create index IF not exists idx_unlocked_achievements_is_claimed on public.unlocked_achievements using btree (is_claimed) TABLESPACE pg_default;

'player_leaderboard'
  create view public.player_leaderboard as
  select
    p.uuid,
    p.name,
    COALESCE(pp.total_points, 0::numeric) as total_points,
    COALESCE(pm.total_medals, 0) as total_medals,
    COALESCE(pm.gold_count, 0) as gold_medals,
    COALESCE(pm.silver_count, 0) as silver_medals,
    COALESCE(pm.bronze_count, 0) as bronze_medals,
    p.last_seen
  from
    players p
    left join player_points pp on p.uuid = pp.player_uuid
    left join player_medals pm on p.uuid = pm.player_uuid
  order by
    (COALESCE(pp.total_points, 0::numeric)) desc;